[
  {
    "objectID": "geographic.html",
    "href": "geographic.html",
    "title": "Geographic Files",
    "section": "",
    "text": "These are the basic formate used to hold the Adjacency file or dual graph for a region to be redistricted. It is based on the JSON output of the NetworkX Python library. An example for a 4x4 grid here grid_graph_4_by_4.json.\nSuch a file contains list of the nodes/vertices as a list under node. A sample node entry is\n    {\n        \"node_name\": \"(0,0)\",\n        \"id\": 0,\n        \"border_length\": 2,\n        \"x_location\": 0,\n        \"y_location\": 0,\n        \"area\": 1,\n        \"population\": 1,\n        \"county\": \"A\"\n    }\nwhere the id, area, population and border_length are required. They give the name by which the vertex/node are referred to as well as the area and population of the partition unit associated to the vertex/node. border_length entry give the length of the external boundary of the partition unit associated to the vertex/node. Hence of a vertex/node is interior this number is zero. The precise labels can be different than these as the name mapping to each piece of data can be specified at runtime.\nOne can also encode additional information. This example gives a node name in node_name, a location in the plane to help with plotting in x_location and y_location. It also records which county the node is in. This example uses fictitious county names of “A” and “B”. Additionally, the vote count for each party in a collection of elections is also often included.\nAfter the list of noted, there is an adjacency entry which contains one list for each of the vertices/nodes. The first list under adjacency gives the vertices/nodes that are adjacent to the first vertex/node listed above.\nFor example of the second entry in the adjacency list is the following list, then the 2nd note is adjacent to the 4th and 5th node listed with a boundary whose length is respectively one and two units.\n{\n    {\n    \"id\": 4,\n    \"length\": 1\n    },\n    {\n    \"id\": 5,\n    \"length\": 2\n    }\n}\n\n\n\nCollection of Sample Adjacency Files\n\n\n\n\n\n\n\nDescription\nFile Name\nComments\n\n\n\n\n4x4 Rectangular Grid\ngrid_graph_4_by_4.json\nSimple regular graph. All nodes have area and population 1. Grid divided into two counties labeled “A” and “B”\n\n\n8x8 Rectangular Grid\ngrid_graph_8_by_8.json\n8x8 version of previous.\n\n\n10x10 Rectangular Grid\ngrid_graph_10_by_10.json\n10x10 version of previous.\n\n\n10x10 Hexagonal Grid\nhex_graph_10_by_10.json\nThe graph is now hexagonal rather than square. Each node in the interior has 6 neighbors. This is the dual graph of a region partitioned into triangles.\n\n\nConnecticut Adjacency Graph\nCT_pct20.json\nPrecinct Adjacency Graph of the state of Connecticut. Contains county names in COUNTY, Precinct name in NAME, 2020 Population in POP20, area and border length in area and border_length, party votes from 2020 presidential general election in G20PREDEM and G20PREREP",
    "crumbs": [
      "Home",
      "Geographic Files"
    ]
  },
  {
    "objectID": "geographic.html#sec-json-adjacency-files",
    "href": "geographic.html#sec-json-adjacency-files",
    "title": "Geographic Files",
    "section": "",
    "text": "These are the basic formate used to hold the Adjacency file or dual graph for a region to be redistricted. It is based on the JSON output of the NetworkX Python library. An example for a 4x4 grid here grid_graph_4_by_4.json.\nSuch a file contains list of the nodes/vertices as a list under node. A sample node entry is\n    {\n        \"node_name\": \"(0,0)\",\n        \"id\": 0,\n        \"border_length\": 2,\n        \"x_location\": 0,\n        \"y_location\": 0,\n        \"area\": 1,\n        \"population\": 1,\n        \"county\": \"A\"\n    }\nwhere the id, area, population and border_length are required. They give the name by which the vertex/node are referred to as well as the area and population of the partition unit associated to the vertex/node. border_length entry give the length of the external boundary of the partition unit associated to the vertex/node. Hence of a vertex/node is interior this number is zero. The precise labels can be different than these as the name mapping to each piece of data can be specified at runtime.\nOne can also encode additional information. This example gives a node name in node_name, a location in the plane to help with plotting in x_location and y_location. It also records which county the node is in. This example uses fictitious county names of “A” and “B”. Additionally, the vote count for each party in a collection of elections is also often included.\nAfter the list of noted, there is an adjacency entry which contains one list for each of the vertices/nodes. The first list under adjacency gives the vertices/nodes that are adjacent to the first vertex/node listed above.\nFor example of the second entry in the adjacency list is the following list, then the 2nd note is adjacent to the 4th and 5th node listed with a boundary whose length is respectively one and two units.\n{\n    {\n    \"id\": 4,\n    \"length\": 1\n    },\n    {\n    \"id\": 5,\n    \"length\": 2\n    }\n}\n\n\n\nCollection of Sample Adjacency Files\n\n\n\n\n\n\n\nDescription\nFile Name\nComments\n\n\n\n\n4x4 Rectangular Grid\ngrid_graph_4_by_4.json\nSimple regular graph. All nodes have area and population 1. Grid divided into two counties labeled “A” and “B”\n\n\n8x8 Rectangular Grid\ngrid_graph_8_by_8.json\n8x8 version of previous.\n\n\n10x10 Rectangular Grid\ngrid_graph_10_by_10.json\n10x10 version of previous.\n\n\n10x10 Hexagonal Grid\nhex_graph_10_by_10.json\nThe graph is now hexagonal rather than square. Each node in the interior has 6 neighbors. This is the dual graph of a region partitioned into triangles.\n\n\nConnecticut Adjacency Graph\nCT_pct20.json\nPrecinct Adjacency Graph of the state of Connecticut. Contains county names in COUNTY, Precinct name in NAME, 2020 Population in POP20, area and border length in area and border_length, party votes from 2020 presidential general election in G20PREDEM and G20PREREP",
    "crumbs": [
      "Home",
      "Geographic Files"
    ]
  },
  {
    "objectID": "geographic.html#shapefiles",
    "href": "geographic.html#shapefiles",
    "title": "Geographic Files",
    "section": "Shapefiles",
    "text": "Shapefiles\nThe shapefile format is a geospatial vector data format for geographic information system (GIS) software. It was developed and regulated by Esri and is used to transfer data between many GIS systems. While the actual shape file has the extension .shp there are also to other required files with the extensions .shx and .dbf. All three are often zipped together into one file and called the “shapefile”. There are tools for creating a JSON adjacency file from a shapefile though a fair bit of cleaning is required.",
    "crumbs": [
      "Home",
      "Geographic Files"
    ]
  },
  {
    "objectID": "geographic.html#geojson",
    "href": "geographic.html#geojson",
    "title": "Geographic Files",
    "section": "GeoJSON",
    "text": "GeoJSON\nGeoJSON is a file formate that is the primary open sourse alternative to the shapefile formate.",
    "crumbs": [
      "Home",
      "Geographic Files"
    ]
  },
  {
    "objectID": "cycleWalk.html",
    "href": "cycleWalk.html",
    "title": "Cycle Walk",
    "section": "",
    "text": "CycleWalk.jl is a registered Julia package that implements the Metropolized Cycle Walk algorithm which is used to sample a used specified distribution on the space of political redistricting plans. This MCMC algorithm is used to create ensemble of redistricting plans that can be used to analyze the impact of different redistricting plans on electoral outcomes.\nMetropolized Cycle Walk supports number of different score/energy functions which are used to define the distribution. The distribution encodes the legal and policy preferences.\nMetropolized Cycle Walk outputs the sampled redistricting into an Atlas file. AtlasIO files can be loaded using Julia or Python using the AtlasIO.jl library.",
    "crumbs": [
      "Home",
      "Cycle Walk"
    ]
  },
  {
    "objectID": "cycleWalk.html#overview",
    "href": "cycleWalk.html#overview",
    "title": "Cycle Walk",
    "section": "",
    "text": "CycleWalk.jl is a registered Julia package that implements the Metropolized Cycle Walk algorithm which is used to sample a used specified distribution on the space of political redistricting plans. This MCMC algorithm is used to create ensemble of redistricting plans that can be used to analyze the impact of different redistricting plans on electoral outcomes.\nMetropolized Cycle Walk supports number of different score/energy functions which are used to define the distribution. The distribution encodes the legal and policy preferences.\nMetropolized Cycle Walk outputs the sampled redistricting into an Atlas file. AtlasIO files can be loaded using Julia or Python using the AtlasIO.jl library.",
    "crumbs": [
      "Home",
      "Cycle Walk"
    ]
  },
  {
    "objectID": "cycleWalk.html#the-metropolized-cycle-walk-algorithm",
    "href": "cycleWalk.html#the-metropolized-cycle-walk-algorithm",
    "title": "Cycle Walk",
    "section": "The Metropolized Cycle Walk Algorithm",
    "text": "The Metropolized Cycle Walk Algorithm\nThe basic Cycle Walk produced \\(d\\)-tree spanning forests where each of the \\(d\\)-spanning trees is approximately balanced in the sense that the total population of each tree is approximately balanced.\nOne step of the Cycle Walk proceeds by either proposing a 1-Tree Cycle Walk or a 2-Tree Cycle Walk. The 1-Tree Cycle Walk adds an edge the tree and then removes and edge from cycle this addition creates so that one again has a tree. The 2-Tree Cycle Walk adds two edges between two adjacent trees and then removes two edges from the cycle these additions creates so that one again has two trees.\nThe Metropolized Cycle Walk algorithm uses these walks as proposals to a Metropolis-Hastings algorithm to sample from a specified target distribution.\nMore details on the algorithm can be found in the [Cycle Walk paper].",
    "crumbs": [
      "Home",
      "Cycle Walk"
    ]
  },
  {
    "objectID": "cycleWalk.html#instillation",
    "href": "cycleWalk.html#instillation",
    "title": "Cycle Walk",
    "section": "Instillation",
    "text": "Instillation\nThe latest released version of the `CycleWalk.jl’ package can be installed from with in Julia by\nusing Pkg\nPkg.add(\"CycleWalk\")\nThis can be done from the commandline in a terminal with\njulia -e 'using Pkg; Pkg.add(\"CycleWalk\")'\n\nLocal Environments\nIt is recommended that you run your Julia session in a local environment to minimize unanticipated side effects from other (unneeded) packages. To add the CycleWalk package to a local environment in the current working directory\nusing Pkg\nPkg.activate(\".\")       # replace this path to keep the local \n                        # environment somewhere else or with a specified name \nPkg.add(\"CycleWalk\")",
    "crumbs": [
      "Home",
      "Cycle Walk"
    ]
  },
  {
    "objectID": "cycleWalk.html#examples",
    "href": "cycleWalk.html#examples",
    "title": "Cycle Walk",
    "section": "Examples",
    "text": "Examples\nIn each example, we will step through the commands task by task. At the end of the section we will collect all of the commands into a complete script you can copy and execute.\n\nA first example: 4x4 rectangular grid\nOur first example will be on a small 4x4 rectangular graph. We choose this example because it executes fast and produces relatively small files. that can be examined by hand. The first step is to download the needed JSON adjacency file. For this example it is call grid_graph_4_by_4.json and was discussed more fully in this Section on JSON Adjacency Files. You can download the file to current directory using the following commandline at the terminal\ncurl   https://jonmjonm.github.io/QGDocs/Geo/Adjacency/grid_graph_4_by_4.json -o grid_graph_4_by_4.json\nNow that we have the needed JSON adjacency file, open a Julia session in the directory with that datafile. We begin by activating out local environment where we have installed the CycleWalk Package and loading the CycleWalk and RandomNumbers packages. If you have not installed the RandomNumbers package you need to execute Pkg.add(\"RandomNumbers\") in a julia window. Make sure you have already activated the environment you intend to use.\nusing Pkg\nPkg.activate(\".\")       #   activate environment \nusing RandomNumbers     #   load Random Number package\nusing CycleWalk         #   load Cycle Walk package\n\nBuild the Graph\nTo load the graph we begin by setting the path to the adjacency file; called grid_graph_4_by_4.json in this case. Next we create a set holding all of the variable names we want to load from the adjacency file. Lastly, we build the graph by specifying the file name, the variable that holds th population and the nodes names, and all of the node data you want load. You need to specify which of the node data names hold the area, border length, and edge parameter data.\n## build graph\npctGraphPath = joinpath(\".\",\"grid_graph_4_by_4.json\")\nnodeData = Set([\"node_name\", \"county\", \"population\", \"area\", \"border_length\"]);\ngraph = build_graph(pctGraphPath, \"population\", \"node_name\", nodeData;\n              area_col=\"area\", node_border_col=\"border_length\", \n              edge_perimeter_col=\"length\")\nThe variable graph is a structure that contains all of the adjacency data as well as all of the data on the vertices and edges.\n\n\nInitialize a Partitions with Constraints\nWe now define the constraints on the phasespace. We specify the number of connected districts in our partition. Beyond the number of constraints, in this case we will also add an absolute constraint on the population deviation. We will require all partitions (also referred to as distractings) to have elements whose relative population deviation from the ideal population is less than allowed_pop_dev. The ideal population is calculated by \\[\\text{Ideal Population}=\\frac{\\text{Total Population}}{\\text{Number of Districts}}\\] then the relative population deviation of the \\(i\\)th district is given by \\[ \\text{$i$th relative population deviation}= \\frac{\\big|\\text{$i$th District Population} - \\text{Ideal Population}\\big|}{\\text{Ideal Population}}\\]\nnum_of_districts=2              # Number of districts\nallowed_pop_dev=0.05            # population deviation (fraction from ideal)\n# initialize constraints \nconstraints = initialize_constraints()\n# add population constraint \nadd_constraint!(constraints, PopulationConstraint(graph, num_of_districts, \n                                                    allowed_pop_dev))\n# initialize a random initial partition\nrng = PCG.PCGStateOneseq(UInt64, 4541901234)    # initialize a random number generator \npartition = LinkCutPartition(graph, constraints, num_of_districts; rng=rng, \n                                verbose=true);\nThere are other choices of constraints one can introduce which we will discuss later.",
    "crumbs": [
      "Home",
      "Cycle Walk"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Quantifying Gerrymandering Documentation",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  }
]