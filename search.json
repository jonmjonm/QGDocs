[
  {
    "objectID": "geographic.html",
    "href": "geographic.html",
    "title": "Geographic Files",
    "section": "",
    "text": "These are the basic formate used to hold the Adjacency file or dual graph for a region to be redistricted. It is based on the JSON output of the NetworkX Python library. An example for a 4x4 grid here grid_graph_4_by_4.json.\nSuch a file contains list of the nodes/vertices as a list under node. A sample node entry is\n    {\n        \"node_name\": \"(0,0)\",\n        \"id\": 0,\n        \"border_length\": 2,\n        \"x_location\": 0,\n        \"y_location\": 0,\n        \"area\": 1,\n        \"population\": 1,\n        \"county\": \"A\"\n    }\nwhere the id, area, population and border_length are required. They give the name by which the vertex/node are referred to as well as the area and population of the partition unit associated to the vertex/node. border_length entry give the length of the external boundary of the partition unit associated to the vertex/node. Hence of a vertex/node is interior this number is zero. The precise labels can be different than these as the name mapping to each piece of data can be specified at runtime.\nOne can also encode additional information. This example gives a node name in node_name, a location in the plane to help with plotting in x_location and y_location. It also records which county the node is in. This example uses fictitious county names of “A” and “B”. Additionally, the vote count for each party in a collection of elections is also often included.\nAfter the list of noted, there is an adjacency entry which contains one list for each of the vertices/nodes. The first list under adjacency gives the vertices/nodes that are adjacent to the first vertex/node listed above.\nFor example of the second entry in the adjacency list is the following list, then the 2nd note is adjacent to the 4th and 5th node listed with a boundary whose length is respectively one and two units.\n{\n    {\n    \"id\": 4,\n    \"length\": 1\n    },\n    {\n    \"id\": 5,\n    \"length\": 2\n    }\n}\n\n\n\nCollection of Sample Adjacency Files\n\n\n\n\n\n\n\nDescription\nFile Name\nComments\n\n\n\n\n4x4 Rectangular Grid\ngrid_graph_4_by_4.json\nSimple regular graph. All nodes have area and population 1. Grid divided into two counties labeled “A” and “B”\n\n\n8x8 Rectangular Grid\ngrid_graph_8_by_8.json\n8x8 version of previous.\n\n\n10x10 Rectangular Grid\ngrid_graph_10_by_10.json\n10x10 version of previous.\n\n\n10x10 Hexagonal Grid\nhex_graph_10_by_10.json\nThe graph is now hexagonal rather than square. Each node in the interior has 6 neighbors. This is the dual graph of a region partitioned into triangles.\n\n\nConnecticut Adjacency Graph\nCT_pct20.json\nPrecinct Adjacency Graph of the state of Connecticut. Contains county names in COUNTY, Precinct name in NAME, 2020 Population in POP20, area and border length in area and border_length, party votes from 2020 presidential general election in G20PREDEM and G20PREREP",
    "crumbs": [
      "Home",
      "Geographic Files"
    ]
  },
  {
    "objectID": "geographic.html#json-adjacency-files",
    "href": "geographic.html#json-adjacency-files",
    "title": "Geographic Files",
    "section": "",
    "text": "These are the basic formate used to hold the Adjacency file or dual graph for a region to be redistricted. It is based on the JSON output of the NetworkX Python library. An example for a 4x4 grid here grid_graph_4_by_4.json.\nSuch a file contains list of the nodes/vertices as a list under node. A sample node entry is\n    {\n        \"node_name\": \"(0,0)\",\n        \"id\": 0,\n        \"border_length\": 2,\n        \"x_location\": 0,\n        \"y_location\": 0,\n        \"area\": 1,\n        \"population\": 1,\n        \"county\": \"A\"\n    }\nwhere the id, area, population and border_length are required. They give the name by which the vertex/node are referred to as well as the area and population of the partition unit associated to the vertex/node. border_length entry give the length of the external boundary of the partition unit associated to the vertex/node. Hence of a vertex/node is interior this number is zero. The precise labels can be different than these as the name mapping to each piece of data can be specified at runtime.\nOne can also encode additional information. This example gives a node name in node_name, a location in the plane to help with plotting in x_location and y_location. It also records which county the node is in. This example uses fictitious county names of “A” and “B”. Additionally, the vote count for each party in a collection of elections is also often included.\nAfter the list of noted, there is an adjacency entry which contains one list for each of the vertices/nodes. The first list under adjacency gives the vertices/nodes that are adjacent to the first vertex/node listed above.\nFor example of the second entry in the adjacency list is the following list, then the 2nd note is adjacent to the 4th and 5th node listed with a boundary whose length is respectively one and two units.\n{\n    {\n    \"id\": 4,\n    \"length\": 1\n    },\n    {\n    \"id\": 5,\n    \"length\": 2\n    }\n}\n\n\n\nCollection of Sample Adjacency Files\n\n\n\n\n\n\n\nDescription\nFile Name\nComments\n\n\n\n\n4x4 Rectangular Grid\ngrid_graph_4_by_4.json\nSimple regular graph. All nodes have area and population 1. Grid divided into two counties labeled “A” and “B”\n\n\n8x8 Rectangular Grid\ngrid_graph_8_by_8.json\n8x8 version of previous.\n\n\n10x10 Rectangular Grid\ngrid_graph_10_by_10.json\n10x10 version of previous.\n\n\n10x10 Hexagonal Grid\nhex_graph_10_by_10.json\nThe graph is now hexagonal rather than square. Each node in the interior has 6 neighbors. This is the dual graph of a region partitioned into triangles.\n\n\nConnecticut Adjacency Graph\nCT_pct20.json\nPrecinct Adjacency Graph of the state of Connecticut. Contains county names in COUNTY, Precinct name in NAME, 2020 Population in POP20, area and border length in area and border_length, party votes from 2020 presidential general election in G20PREDEM and G20PREREP",
    "crumbs": [
      "Home",
      "Geographic Files"
    ]
  },
  {
    "objectID": "geographic.html#shapefiles",
    "href": "geographic.html#shapefiles",
    "title": "Geographic Files",
    "section": "Shapefiles",
    "text": "Shapefiles\nThe shapefile format is a geospatial vector data format for geographic information system (GIS) software. It was developed and regulated by Esri and is used to transfer data between many GIS systems. While the actual shape file has the extension .shp there are also to other required files with the extensions .shx and .dbf. All three are often zipped together into one file and called the “shapefile”. There are tools for creating a JSON adjacency file from a shapefile though a fair bit of cleaning is required.",
    "crumbs": [
      "Home",
      "Geographic Files"
    ]
  },
  {
    "objectID": "geographic.html#geojson",
    "href": "geographic.html#geojson",
    "title": "Geographic Files",
    "section": "GeoJSON",
    "text": "GeoJSON\nGeoJSON is a file formate that is the primary open sourse alternative to the shapefile formate.",
    "crumbs": [
      "Home",
      "Geographic Files"
    ]
  },
  {
    "objectID": "cycleWalk.html",
    "href": "cycleWalk.html",
    "title": "Cycle Walk",
    "section": "",
    "text": "CycleWalk.jl is a registered Julia package that implements the Metropolized Cycle Walk algorithm which is used to sample a used specified distribution on the space of political redistricting plans. This MCMC algorithm is used to create ensemble of redistricting plans that can be used to analyze the impact of different redistricting plans on electoral outcomes.\nMetropolized Cycle Walk supports number of different score/energy functions which are used to define the distribution. The distribution encodes the legal and policy preferences.\nMetropolized Cycle Walk outputs the sampled redistricting into an Atlas file. AtlasIO files can be loaded using Julia or Python using the AtlasIO.jl library.",
    "crumbs": [
      "Home",
      "Cycle Walk"
    ]
  },
  {
    "objectID": "cycleWalk.html#overview",
    "href": "cycleWalk.html#overview",
    "title": "Cycle Walk",
    "section": "",
    "text": "CycleWalk.jl is a registered Julia package that implements the Metropolized Cycle Walk algorithm which is used to sample a used specified distribution on the space of political redistricting plans. This MCMC algorithm is used to create ensemble of redistricting plans that can be used to analyze the impact of different redistricting plans on electoral outcomes.\nMetropolized Cycle Walk supports number of different score/energy functions which are used to define the distribution. The distribution encodes the legal and policy preferences.\nMetropolized Cycle Walk outputs the sampled redistricting into an Atlas file. AtlasIO files can be loaded using Julia or Python using the AtlasIO.jl library.",
    "crumbs": [
      "Home",
      "Cycle Walk"
    ]
  },
  {
    "objectID": "cycleWalk.html#the-metropolized-cycle-walk-algorithm",
    "href": "cycleWalk.html#the-metropolized-cycle-walk-algorithm",
    "title": "Cycle Walk",
    "section": "The Metropolized Cycle Walk Algorithm",
    "text": "The Metropolized Cycle Walk Algorithm\nThe basic Cycle Walk produced \\(d\\)-tree spanning forests where each of the \\(d\\)-spanning trees is approximately balanced in the sense that the total population of each tree is approximately balanced.\nOne step of the Cycle Walk proceeds by either proposing a 1-Tree Cycle Walk or a 2-Tree Cycle Walk. The 1-Tree Cycle Walk adds an edge the tree and then removes and edge from cycle this addition creates so that one again has a tree. The 2-Tree Cycle Walk adds two edges between two adjacent trees and then removes two edges from the cycle these additions creates so that one again has two trees.\nThe Metropolized Cycle Walk algorithm uses these walks as proposals to a Metropolis-Hastings algorithm to sample from a specified target distribution.\nMore details on the algorithm can be found in the [Cycle Walk paper].",
    "crumbs": [
      "Home",
      "Cycle Walk"
    ]
  },
  {
    "objectID": "cycleWalk.html#instillation",
    "href": "cycleWalk.html#instillation",
    "title": "Cycle Walk",
    "section": "Instillation",
    "text": "Instillation\nThe latest released version of the `CycleWalk.jl’ package can be installed from with in Julia by\n```{julia}\nusing Pkg\nPkg.add(\"CycleWalk\")\n```",
    "crumbs": [
      "Home",
      "Cycle Walk"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Quantifying Gerrymandering Documentation",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  }
]