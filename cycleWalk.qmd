---
title: "Cycle Walk"
format: html
engine: julia
bibliography: ref.bib
---
## Overview

CycleWalk.jl is a registered Julia package that implements the Metropolized Cycle Walk algorithm which is used to sample a used specified distribution on the space of political redistricting plans. This MCMC algorithm is used to create ensemble of redistricting plans that can be used to analyze the impact of different redistricting plans on electoral outcomes.

Metropolized Cycle Walk supports number of different score/energy functions which are used to define the distribution. The distribution encodes the legal and policy preferences.

Metropolized Cycle Walk outputs the sampled redistricting into an Atlas file. AtlasIO files can be loaded using Julia or Python using the AtlasIO.jl library.

## The Metropolized Cycle Walk Algorithm
The basic Cycle Walk produced 
$d$-tree spanning forests where each of the 
$d$-spanning trees is approximately balanced in the sense that the total population of each tree is approximately balanced.

One step of the Cycle Walk proceeds by either proposing a 1-Tree Cycle Walk or a 2-Tree Cycle Walk. The 1-Tree Cycle Walk adds an edge the tree and then removes and edge from cycle this addition creates so that one again has a tree. The 2-Tree Cycle Walk adds two edges between two adjacent trees and then removes two edges from the cycle these additions creates so that one again has two trees.

The Metropolized Cycle Walk algorithm uses these walks as proposals to a Metropolis-Hastings algorithm to sample from a specified target distribution.

More details on the algorithm can be found in the [@deford2025cyclewalksamplingmeasures].

## Instillation

The latest released version of the `CycleWalk.jl` package can be installed from with in Julia by 

```{.julia}
using Pkg
Pkg.add("CycleWalk")
```

This can be done from the commandline in a terminal with 
```{.sh}
julia -e 'using Pkg; Pkg.add("CycleWalk")'
```
If you have not installed Julia, it is remended that you instal the `juliaup` command and use it to instal `julia`. Direction can be found here: [juliaup](https://julialang.org/install/) .

#### Local Environments

It is recommended that you run your Julia session in a local environment to minimize unanticipated side effects from other (unneeded) packages. To add the CycleWalk package to a local environment in the current working directory 
```{.julia}
using Pkg
Pkg.activate(".")       # replace this path to keep the local 
                        # environment somewhere else or with a specified name 
Pkg.add("CycleWalk")
```
## Examples
In each example, we will step through the commands task by task. At the end of the section we will collect all of the commands into a complete script you can copy and execute.

### A first example: 4x4 rectangular grid
Our first example will be on a small 4x4 rectangular graph. We choose this example because it executes fast and produces relatively small files. that can be examined by hand. The first step is to download the needed JSON adjacency file. For this example it is call [grid_graph_4_by_4.json](Geo/Adjacency/grid_graph_4_by_4.json) and was discussed more fully in [this Section on JSON Adjacency Files](geographic.html#sec-json-adjacency-files). You can download the file to current directory using the following commandline at the terminal
```{.sh}
curl   https://jonmjonm.github.io/QGDocs/Geo/Adjacency/grid_graph_4_by_4.json -o grid_graph_4_by_4.json
```


Now that we have the needed JSON adjacency file, open a Julia session in the directory with that datafile. We begin by activating out local environment where we have installed the CycleWalk Package and loading the `CycleWalk` and `RandomNumbers` packages. If you have not installed the `RandomNumbers` package you need to execute  `Pkg.add("RandomNumbers")` in a julia window. Make sure you have already activated the environment you intend to use.
```{.julia}
using Pkg
Pkg.activate(".")       #   activate environment 
using RandomNumbers     #   load Random Number package
using CycleWalk         #   load Cycle Walk package
```

#### Build the Graph
To load the graph we begin by setting the path to the adjacency file; called `grid_graph_4_by_4.json` in this case. Next we create a set holding all of the variable names we want to load from the adjacency file. Lastly, we build the graph by specifying the file name, the variable that holds th population and the nodes names, and all of the node data you want load. You need to specify which of the node data names hold the area, border length, and edge parameter data.
```{.julia}
## build graph
pctGraphPath = joinpath(".","grid_graph_4_by_4.json")
nodeData = Set(["node_name", "county", "population", "area", "border_length"]);
graph = build_graph(pctGraphPath, "population", "node_name", nodeData;
              area_col="area", node_border_col="border_length", 
              edge_perimeter_col="length")

```

The variable `graph` is a structure that contains all of the adjacency data as well as all of the data on the vertices and edges. 


#### Initialize a random Forest Partitions with specified Constraints
We now define the constraints on the phasespace. We specify the number of connected districts in our forest partition. We will use the term *Forest Partition* with $d$ elements to describe a spanning forest with $d$ disjoint spanning trees. The vertices/nodes in each spanning tree will be the elements of the  partition of vertices/nodes induced by the  *Forest Partition*.  Beyond the number of constraints, in this case we will also add an absolute constraint on the population deviation. We will require all partitions (also referred to as distractings)  to have elements whose relative population deviation from the ideal population is less than `allowed_pop_dev`. The ideal population is calculated by
$$\text{Ideal Population}=\frac{\text{Total Population}}{\text{Number of Districts}}$$
then the relative population deviation of the $i$th district is given by
$$ \text{$i$th relative population deviation}= \frac{\big|\text{$i$th District Population} - \text{Ideal Population}\big|}{\text{Ideal Population}}$$

```{.julia}
num_of_districts=2              # Number of districts
allowed_pop_dev=0.05            # population deviation (fraction from ideal)
# initialize constraints 
constraints = initialize_constraints()
# add population constraint 
add_constraint!(constraints, PopulationConstraint(graph, num_of_districts, 
                                                    allowed_pop_dev))
# initialize a random initial partition
rng = PCG.PCGStateOneseq(UInt64, 4541901234)    # initialize a random number generator 
partition = LinkCutPartition(graph, constraints, num_of_districts; rng=rng, 
                                verbose=true);
```

There are other choices of constraints one can introduce which we will discuss later. The `LinkCutPartition` function tries to generate though a random algorithm a partition with `num_of_districts` districts that satisfies the specified constraints. It tires up to on the order of 100 times and returns the first acceptable partition generated. If all of the attempts fail, it throws an error message.

#### Defining the Measure {#sec-define-measure}
Next we define the target measure we want to sample from. In this simple example we will only consider *log spanning forest* energy that we will denote by $h(\xi)$ for a given  partition $\xi$. It is defined by 
$h(\xi)=\log \text{Tree}(\xi)$ where $\text{Tree}(\xi)$ is the number spanning forest which induce the given partition $\xi$.
When the parameter $\gamma$ bellow is taken to be zero then the measure is uniform on spanning forests while $\gamma=1$ corresponds to uniform on partitions. Normally, it is not wise to consider the uniform measure on partitions without an isoparmetric energy in the measure. However on a small graph like this, it does not matter.

```{.julia}
measure = Measure()     # build measure
gamma=0.0               # typically a number in [0,1]
push_energy!(measure, get_log_spanning_forests, gamma) # add spanning forests energy
```

#### Build the Proposal for Metropolis–Hastings MCMC

We now build the Markov Chain that will be used as a proposal in a [Metropolis–Hastings](https://en.wikipedia.org/wiki/Metropolis%E2%80%93Hastings_algorithm) Algorithm to construct a markov chains guaranteed to have the measure constructed [above](#sec-define-measure) as a stationary measure. 

```{.julia}
cycle_walk_2_tree = build_two_tree_cycle_walk(constraints)
cycle_walk_1_tree = build_one_tree_cycle_walk(constraints)
twocycle_frac=0.1   # fraction of 2-tree cycle walks among total walks
proposal = [(twocycle_frac, cycle_walk_2_tree), 
            (1.0-twocycle_frac, cycle_walk_1_tree)]
```

#### Choose the Output

We now establish the name of the output file as well as fix a few parameters we want to be written to the file in addition to the vertex/node assignment that makes the current partition. 

```{.julia}
atlasName = "cycleWalk"*"_grid4x4_" * "_gamma" * string(gamma)*"_kappa"*string(twocycle_frac) *".jsonl"
output_file_path = joinpath("output","grid", atlasName) 
```

Next we construct a map writer that will output the current districting as well as some selected statistics about the districting and the run so far.

```{.julia}
ad_param = Dict{String, Any}("popdev" => allowed_pop_dev)   # specific info to write
writer = Writer(measure, constraints, partition, output_file_path; 
                additional_parameters=ad_param)
push_writer!(writer, get_log_spanning_trees)        # add spanning trees count to writer
push_writer!(writer, get_log_spanning_forests)      # add spanning forests count to writer
push_writer!(writer, get_isoperimetric_scores)      # add isoperimetric scores to writer
```

#### Run the Markov Chain

We now run the metropolized Cycle Walk with the proposal we constructed above.

```{.julia}
cycle_walk_2_tree_steps = 100
steps = Int(cycle_walk_2_tree_steps/twocycle_frac)
outfreq = Int(1/twocycle_frac)
```



```{.julia}
println("running mcmc; outputting here: "* output_file_path)
run_metropolis_hastings!(partition, proposal, measure, steps, rng,
                         writer=writer, output_freq=outfreq)
close_writer(writer) # close atlas
```

#### Putting Everything Together

```{.julia}
using Pkg
Pkg.activate(".")       #   activate environment 
using RandomNumbers     #   load Random Number package
using CycleWalk         #   load Cycle Walk package

## build graph
pctGraphPath = joinpath(".","grid_graph_4_by_4.json")
nodeData = Set(["node_name", "county", "population", "area", "border_length"]);
graph = build_graph(pctGraphPath, "population", "node_name", nodeData;
              area_col="area", node_border_col="border_length", 
              edge_perimeter_col="length")

num_of_districts=2              # Number of districts
allowed_pop_dev=0.05            # population deviation (fraction from ideal)
# initialize constraints 
constraints = initialize_constraints()
# add population constraint 
add_constraint!(constraints, PopulationConstraint(graph, num_of_districts, 
                                                    allowed_pop_dev))
# initialize a random initial partition
rng = PCG.PCGStateOneseq(UInt64, 4541901234)    # initialize a random number generator 
partition = LinkCutPartition(graph, constraints, num_of_districts; rng=rng, 
                                verbose=true);

measure = Measure()     # build measure
gamma=0.0               # typically a number in [0,1]
push_energy!(measure, get_log_spanning_forests, gamma) # add spanning forests energy

cycle_walk_2_tree = build_two_tree_cycle_walk(constraints)
cycle_walk_1_tree = build_one_tree_cycle_walk(constraints)
twocycle_frac=0.1   # fraction of 2-tree cycle walks among total walks
proposal = [(twocycle_frac, cycle_walk_2_tree), 
            (1.0-twocycle_frac, cycle_walk_1_tree)]

#set output file name
atlasName = "cycleWalk"*"_grid4x4_" * "_gamma" * string(gamma)*"_kappa"*string(twocycle_frac) *".jsonl"
output_file_path = joinpath("output","grid", atlasName) 

# create writer and open output atlas
ad_param = Dict{String, Any}("popdev" => allowed_pop_dev)   # specific info to write
writer = Writer(measure, constraints, partition, output_file_path; 
                additional_parameters=ad_param)
push_writer!(writer, get_log_spanning_trees)        # add spanning trees count to writer
push_writer!(writer, get_log_spanning_forests)      # add spanning forests count to writer
push_writer!(writer, get_isoperimetric_scores)      # add isoperimetric scores to writer

# Run the MCMC
cycle_walk_2_tree_steps = 100
steps = Int(cycle_walk_2_tree_steps/twocycle_frac)
outfreq = Int(1/twocycle_frac)

println("running mcmc; outputting here: "* output_file_path)
run_metropolis_hastings!(partition, proposal, measure, steps, rng,
                         writer=writer, output_freq=outfreq)
close_writer(writer) # close atlas

```

After you run the script, look at the file generate. It should be inside the directory `output/grid/` and named something like `cycleWalk_grid4x4__gamma0.0_kappa0.1.jsonl`. It should  look something like the following file. Of course the details will be different as your random seed might be different. Notice that the first three lines describe the Atlas file while the fourth line on are the individual maps that were saved.


<div class="scrollable-content">
```{.json}
{{< include examples/cycleWalk_grid4x4__gamma0.0_kappa0.1.jsonl >}}
```
</div>

### A second example: 10x10 hexagonal grid

We now consider a small variation on our previous example. We consider a planner region with a regular triangulation. The dual/adjacency graph is a hexagonal lattice. We begin by downloading the needed JSON adjacency file to our current directory.

```{.sh}
curl  https://jonmjonm.github.io/QGDocs/Geo/Adjacency/hex_graph_10_by_10.json -o hex_graph_10_by_10.json
```

#### A Modified Script 

We now give code to run on the 10x10 hexagonal lattice. It will only require some small modifications from the previous example given above. Beyond the obvious such as modifying the input and output files, we will also increase the number of districts to 4 and decrease the allowed population deviation. This last step is possible as the number of element in each district increases providing finer granularity. We will also introduce an isodiametric score in the target measure to keep the districts compact no matter what constant is placed in front of the log spanning forests term in the energy. Recall that as that constant goes to one, the  log spanning forests energy causes the probability measure to converge to the uniform measure on partitions if no other weights are used.  The uniform measure on partitions is full of space-filling partitions that are very, very non-compact.

```{.julia code-line-numbers="true"}
using Pkg
Pkg.activate(".")       #   activate environment 
using RandomNumbers     #   load Random Number package
using CycleWalk         #   load Cycle Walk package

## build graph
pctGraphPath = joinpath(".","hex_graph_10_by_10.json")
nodeData = Set(["node_name", "county", "population", "area", "border_length"]);
graph = build_graph(pctGraphPath, "population", "node_name", nodeData;
              area_col="area", node_border_col="border_length", 
              edge_perimeter_col="length")

num_of_districts=5              # Number of districts
allowed_pop_dev=0.02            # population deviation (fraction from ideal)
# initialize constraints 
constraints = initialize_constraints()
# add population constraint 
add_constraint!(constraints, PopulationConstraint(graph, num_of_districts, 
                                                    allowed_pop_dev))
# initialize a random initial partition
rng = PCG.PCGStateOneseq(UInt64, 4541901234)    # initialize a random number generator 
partition = LinkCutPartition(graph, constraints, num_of_districts; rng=rng, 
                                verbose=true);

measure = Measure()     # build measure
gamma=0.0               # typically a number in [0,1]
iso_weight= 0.3         # weight on the sum of isoperimetric ratios; i.e. Polsby-Popper
push_energy!(measure, get_log_spanning_forests, gamma) # add spanning forests energy
push_energy!(measure, get_isoperimetric_score, iso_weight) # add isoperimetric score energy

cycle_walk_2_tree = build_two_tree_cycle_walk(constraints)
cycle_walk_1_tree = build_one_tree_cycle_walk(constraints)
twocycle_frac=0.1   # fraction of 2-tree cycle walks among total walks
proposal = [(twocycle_frac, cycle_walk_2_tree), 
            (1.0-twocycle_frac, cycle_walk_1_tree)]

#set output file name
atlasName = "cycleWalk"*"_hex10x10_" * "_gamma" * string(gamma)*"_kappa"
atlasName*= string(twocycle_frac)*"_iso"*string(iso_weight)*".jsonl"

output_file_path = joinpath("output","grid", atlasName) 

# create writer and open output atlas
ad_param = Dict{String, Any}("popdev" => allowed_pop_dev)   # specific info to write
writer = Writer(measure, constraints, partition, output_file_path; 
                additional_parameters=ad_param)
push_writer!(writer, get_log_spanning_trees)        # add spanning trees count to writer
push_writer!(writer, get_log_spanning_forests)      # add spanning forests count to writer
push_writer!(writer, get_isoperimetric_scores)      # add isoperimetric scores to writer

# Run the MCMC
cycle_walk_2_tree_steps = 100
steps = Int(cycle_walk_2_tree_steps/twocycle_frac)
outfreq = Int(1/twocycle_frac)

println("running mcmc; outputting here: "* output_file_path)
run_metropolis_hastings!(partition, proposal, measure, steps, rng,
                         writer=writer, output_freq=outfreq)
close_writer(writer) # close atlas
```

The lines change are 7, 13, 14, 27, 29, 38 and 39. Of these the most important of the non-cosmetic changes is the introduction of the isoparmetric score in line 29.

### A small realistic example: Connecticut Congressional Districts.

We now consider a smaller but realistic example of generating district maps for Connecticut with five confusional districts. As before, we begin by downloading the needed JSON adjacency file for Connecticut.

```{.julia}
curl  https://jonmjonm.github.io/QGDocs/Geo/Adjacency/CT_pct20.json -o CT_pct20.json
```

```{.julia}
import Pkg
Pkg.activate(".")
using RandomNumbers
using CycleWalk

twocycle_frac = 0.1
gamma = 0.0 # 0 is spanning forest measure, 1 is partition
iso_weight = 0.3 # weight on the sum of isoperimetric ratios; i.e. Polsby-Popper
num_dists = 5

@assert 0 ≤ twocycle_frac ≤ 1

rng = PCG.PCGStateOneseq(UInt64, 4541901234)
pop_dev = 0.02 # population deviation (fraction from ideal)
cycle_walk_steps = 10^4
steps = Int(cycle_walk_steps/twocycle_frac)
outfreq = Int(400/twocycle_frac)

## build graph
pctGraphPath = joinpath(".","CT_pct20.json")
nodeData = Set(["COUNTY", "NAME", "POP20", "area", "border_length"]);
graph = build_graph(pctGraphPath, "POP20", "NAME", nodeData;
              area_col="area", node_border_col="border_length", 
              edge_perimeter_col="length")

## build partition
constraints = initialize_constraints()
add_constraint!(constraints, PopulationConstraint(graph, num_dists, pop_dev))
partition = LinkCutPartition(graph, constraints, num_dists; rng=rng, 
                             verbose=true);

## build proposal
cycle_walk_2_tree = build_two_tree_cycle_walk(constraints)
cycle_walk_1_tree = build_one_tree_cycle_walk(constraints)
proposal = [(twocycle_frac, cycle_walk_2_tree), 
            (1.0-twocycle_frac, cycle_walk_1_tree)]

## build measure
measure = Measure()
push_energy!(measure, get_log_spanning_forests, gamma) # add spanning forests energy
push_energy!(measure, get_isoperimetric_score, iso_weight) # add isoperimetric score energy

## establish output name and path
atlasName = "cycleWalk_ct_kappa"*string(twocycle_frac)
atlasName *= "_gamma"*string(gamma)
atlasName *= "_iso"*string(iso_weight)
atlasName *= ".jsonl.gz" # or just ".jsonl" for an uncompressed output
output_file_path = joinpath("output","ct", atlasName) # add output directory to path

## establish writer to which the output will be written
ad_param = Dict{String, Any}("popdev" => pop_dev) # specific info to write
writer = Writer(measure, constraints, partition, output_file_path; 
                additional_parameters=ad_param)
push_writer!(writer, get_log_spanning_trees) # add spanning trees count to writer
push_writer!(writer, get_log_spanning_forests) # add spanning forests count to writer
push_writer!(writer, get_isoperimetric_scores) # add isoperimetric scores to writer

## run MCMC sampler
println("running mcmc; outputting here: "* output_file_path)
run_metropolis_hastings!(partition, proposal, measure, steps, rng,
                         writer=writer, output_freq=outfreq)
close_writer(writer) # close atlas
```


### A larger realistic example: North Carolina Congressional Districts.

We now consider a smaller but realistic example of generating district maps for North Carolina with 14 confusional districts. As before, we begin by downloading the needed JSON adjacency file for North Carolina.

```{.sh}
curl   https://raw.githubusercontent.com/jonmjonm/QGDocs/refs/heads/main/Geo/Adjacency/NC_pct21.json -o NC_pct21.json
```

```{.julia}
import Pkg
Pkg.activate(".")
using RandomNumbers
using CycleWalk

twocycle_frac = 0.1
gamma = 0.0 # 0 is spanning forest measure, 1 is partition
iso_weight = 0.45 # weight on the sum of isoperimetric ratios; i.e. Polsby-Popper
num_dists = 14

@assert 0 ≤ twocycle_frac ≤ 1

rng = PCG.PCGStateOneseq(UInt64, 4541901234)
pop_dev = 0.02 # population deviation (fraction from ideal)
cycle_walk_steps = 10^3
steps = Int(cycle_walk_steps/twocycle_frac)
outfreq = Int(400/twocycle_frac)

## build graph
pctGraphPath = joinpath(".","NC_pct21.json")
nodeData = Set(["county", "prec_id", "pop2020cen", "area", "border_length"]);
graph = build_graph(pctGraphPath, "pop2020cen", "prec_id", nodeData;
              area_col="area", node_border_col="border_length", 
              edge_perimeter_col="length")

## build partition
constraints = initialize_constraints()
add_constraint!(constraints, PopulationConstraint(graph, num_dists, pop_dev))
partition = LinkCutPartition(graph, constraints, num_dists; rng=rng, 
                             verbose=true);

## build proposal
cycle_walk_2_tree = build_two_tree_cycle_walk(constraints)
cycle_walk_1_tree = build_one_tree_cycle_walk(constraints)
proposal = [(twocycle_frac, cycle_walk_2_tree), 
            (1.0-twocycle_frac, cycle_walk_1_tree)]

## build measure
measure = Measure()
push_energy!(measure, get_log_spanning_forests, gamma) # add spanning forests energy
push_energy!(measure, get_isoperimetric_score, iso_weight) # add isoperimetric score energy

## establish output name and path
atlasName = "cycleWalk_nc_kappa"*string(twocycle_frac)
atlasName *= "_gamma"*string(gamma)
atlasName *= "_iso"*string(iso_weight)
atlasName *= ".jsonl.gz" # or just ".jsonl" for an uncompressed output
output_file_path = joinpath("output","nc", atlasName) # add output directory to path

## establish writer to which the output will be written
ad_param = Dict{String, Any}("popdev" => pop_dev) # specific info to write
writer = Writer(measure, constraints, partition, output_file_path; 
                additional_parameters=ad_param)
push_writer!(writer, get_log_spanning_trees) # add spanning trees count to writer
push_writer!(writer, get_log_spanning_forests) # add spanning forests count to writer
push_writer!(writer, get_isoperimetric_scores) # add isoperimetric scores to writer

## run MCMC sampler
println("running mcmc; outputting here: "* output_file_path)
run_metropolis_hastings!(partition, proposal, measure, steps, rng,
                         writer=writer, output_freq=outfreq)
close_writer(writer) # close atlas
```