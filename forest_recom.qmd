---
title: "Metropolized Forest RECOM"
format: html
bibliography: ref.bib
---

### Overview

Metropolized Forest Recom [@autry2023metropolized,@autry2021metropolized] is an extension of the Recom (or Recombination) algorithm developed by DeFord, Duchin, and Solomon [@deford2019recombination]. It modifies the original, whose stationary measure is unknown, to an algorithm that is computational feasible to use as a proposal for a Metropolis-Hastings scheme. This gives the user better knowledge of what measure the ensample of maps has been drawn from and how they prioritize various legal and cultural norms in redistricting.

Additionally, the multiscale version has been used with great success to create redistrictings that preserve particular geographic structures. In our experience it work  better than weights or score functions. This is  especially true when one wants approach the minimum number of county splits possible.

There have been a number of different code bases that implemented this algorithm, include ones in C++, Python and Julia. We currently recommend the Julia codebase that is official Julia package and hence can be installed using the Julia Package manager. 

More information can be found at the [Git Repository](https://github.com/jonmjonm/MetropolizedForestRecom.jl).

### Instillation

Metropolized Forest Recom is writing in the Julia programming language and registered as an official Julia package. It can be installed  using the Julia package manager. Generally it is recommended that you run the code in an local environment. This can be done with the `activate` command. After activating the environment, we need to install the needed packages. 

```{.julia}
using Pkg
Pkg.activate(".")
Pkg.add("RandomNumbers")
Pkg.add("MetropolizedForestRecom")
```
Once this instillation is complete, one can activate the local environment and load the needed packages as follows.

```{.julia}
using Pkg
Pkg.activate(".")
using RandomNumbers
using MetropolizedForestRecom
```

### A one-level example on NC



#### Download the Adjacency File

The first step is to download the needed JSON adjacency file. For this example it is call [NC_pct21.json](Geo/Adjacency/NC_pct21.json) and was discussed more fully in [this Section on JSON Adjacency Files](geographic.html#sec-json-adjacency-files). You can download the file to current directory using the following commandline at the terminal
```{.sh}
curl   https://raw.githubusercontent.com/jonmjonm/QGDocs/refs/heads/main/Geo/Adjacency/NC_pct21.json -o NC_pct21.json
```

#### Initialize the Graph

```{.julia}
# manually read in base_graph so that we can set a unique identifier that 
# combines county and precinct id
pctGraphPath = joinpath(".", "NC_pct21.json")
nodeData = Set(["county", "prec_id", "pop2020cen", "area", "border_length"]);
base_graph = BaseGraph(pctGraphPath, "pop2020cen", inc_node_data=nodeData,
                       area_col="area", node_border_col="border_length",
                       edge_perimeter_col="length", edge_weights="connections");
# combines county and precinct id
for ii = 1:length(base_graph.node_attributes)
    county = base_graph.node_attributes[ii]["county"]
    prec_id = base_graph.node_attributes[ii]["prec_id"]
    name = county*"_"*prec_id
    base_graph.node_attributes[ii]["county_and_prec_id"] = name
end
# now that the field "county_and_prec_id" is set, we can use it to create the 
# graph object that we will sample on
graph = Graph(base_graph, "county_and_prec_id");
```

#### Add Constraints and Initial Random Partition 

```{.julia}
# add constraints
num_dists=14 
pop_dev = 0.02
constraints = initialize_constraints()
add_constraint!(constraints, PopulationConstraint(graph, num_dists, pop_dev))

# create initial random partition
rng_seed = 110934571
rng = PCG.PCGStateOneseq(UInt64, rng_seed)
partition = Partition(graph, constraints, num_dists; rng=rng);
```

#### Build Metropolis-Hastings Proposal Chain

```{.julia}
proposal = build_forest_recom2(constraints)
```


#### Specify Target Measure

```{.julia}
gamma=0.0;
alpha=1.1;
iso=0.45;
measure = Measure(gamma, alpha); # spanning forest measure; 
                            # first number is exponent on trees, second on linking edges
push_measure!(measure, get_isoperimetric_score, iso); # add iso parametric score
```

#### Set Output

```{.juila}
output_file_path = joinpath("output", "nc", 
                            "metropolizedForestRECOM_1level_gamma"*string(gamma)*"_iso"*string(iso)*".jsonl.gz")
writer = Writer(measure, constraints, partition, output_file_path)
push_writer!(writer, get_log_spanning_trees)
push_writer!(writer, get_log_spanning_forests)
push_writer!(writer, get_isoperimetric_scores)
```


#### Run Metropolized MCMC


```{.julia}
steps=steps = 100
output_freq=1
println("startring mcmc")
run_metropolis_hastings!(partition, proposal, measure, steps, rng,
                         writer=writer, output_freq=output_freq);
```


#### Putting Everything Together

```{.julia}


```